<!DOCTYPE html>
<html lang="es">
<head>
    <style>
        /* ... (your existing styles) ... */

        /* Style for the interval selector */
        .interval-selector-container {
            margin-top: 1rem; /* Space above the selector */
            margin-bottom: 1.5rem; /* Space below the selector */
            padding: 1rem;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .interval-selector-container label {
            font-size: 0.95rem;
            font-weight: 500;
            color: #374151; /* Tailwind gray-700 */
        }
        .interval-selector-container select {
            padding: 0.6rem 0.8rem;
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 0.5rem;
            font-size: 0.9rem;
            flex-grow: 1;
            max-width: 250px; /* Max width for the select */
        }
        .interval-selector-container select:focus {
            outline: none;
            border-color: #3b82f6; /* Tailwind blue-500 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }

        /* Ensure chart container allows for scrolling */
        #chartContainer {
            /* ... (existing styles for chartContainer) ... */
            overflow-x: auto; /* Enable horizontal scroll */
            position: relative; /* Needed for potential absolute positioning of canvas or other elements */
        }
    </style>
</head>
<body>
    <main id="mainContent">
        <div class="dashboard-container">
            <h1 class="page-title">Panel de Constantes Vitales</h1>

            <div id="chartContainer">
                <canvas id="vitalSignsChart"></canvas>
            </div>

            <div class="interval-selector-container">
                <label for="timeIntervalSelector">Mostrar Rango:</label>
                <select id="timeIntervalSelector">
                    <option value="24h" selected>Último Día (24h)</option>
                    <option value="3days">Últimos 3 Días</option>
                    <option value="1week">Última Semana</option>
                    <option value="2weeks">Últimas 2 Semanas</option>
                    <option value="1month">Último Mes</option>
                </select>
            </div>
    
            </div>
    </main>

    <script>
        // --- Datos Globales y Estado ---
        let patientData = [ // Datos iniciales de ejemplo
            { fecha: "2024-05-20", turno: "M", temp: 36.5, tas: 120, tad: 80, fc: 70, fr: 16, sato2: 98 },
            { fecha: "2024-05-20", turno: "T", temp: 37.0, tas: 122, tad: 81, fc: 75, fr: 18, sato2: 97 },
            { fecha: "2024-05-20", turno: "N", temp: 36.9, tas: 121, tad: 79, fc: 72, fr: 17, sato2: 98 },
            { fecha: "2024-05-21", turno: "M", temp: 36.8, tas: 118, tad: 78, fc: 68, fr: 15, sato2: 99 },
            { fecha: "2024-05-21", turno: "T", temp: 37.1, tas: 120, tad: 80, fc: 70, fr: 16, sato2: 97 },
        ];
        let vitalSignsChart;
        let isSidebarCollapsed = false;
        let currentlyDisplayedData = []; // To hold data passed to chart for annotations

        // --- Elementos del DOM (Dashboard) ---
        const ctx = document.getElementById('vitalSignsChart').getContext('2d');
        const inputFecha = document.getElementById('inputFecha');
        // ... (otros elementos del DOM que ya tienes)
        const timeIntervalSelector = document.getElementById('timeIntervalSelector'); // Nuevo selector

        // --- Elementos del DOM (Sidebar y Modal) ---
        // ... (tus elementos del DOM existentes) ...


        // --- Lógica de Sidebar y Navegación Modal ---
        // ... (tu lógica existente) ...

        // --- Lógica del Cargador de CSV (Modal) ---
        // ... (tu lógica existente, asegurate que transformAndSetGlobalPatientData llama a updateChartView) ...

        function transformAndSetGlobalPatientData(parsedCsvData, csvHeaders) {
            // ... (tu lógica existente para parsear y transformar) ...
            // Al final de esta función, después de patientData = transformed;
            // patientData = transformed; // Esta línea ya existe
            // console.log("PatientData global actualizado:", patientData);
            
            // Añadido: Actualizar la vista del gráfico con los nuevos datos cargados y el intervalo seleccionado
            if (patientData.length > 0) {
                 showMessageInModal(`Datos de '${csvHeaders}' procesados y aplicados al gráfico.`, 'success');
                 updateChartView(); // Actualiza el gráfico con los nuevos datos y el selector actual
                 renderDataTable(); // Actualiza la tabla también
            } else {
                showMessageInModal(`No se pudieron transformar datos válidos del CSV de '${csvHeaders}'. Verifica el formato y las cabeceras.`, 'error');
                // Si no hay datos, podríamos querer limpiar el gráfico o mostrar un mensaje
                if (vitalSignsChart) vitalSignsChart.destroy();
                dataTableBody.innerHTML = ''; // Limpiar tabla
            }
        }


        // --- Nueva Lógica para el Gráfico Mejorado ---

        /**
         * Convierte una entrada de patientData a un objeto Date para el eje de tiempo.
         * Asigna horas fijas a los turnos M, T, N.
         */
        function getTimestampFromDataPoint(dataEntry) {
            if (!dataEntry || !dataEntry.fecha || !dataEntry.turno) {
                console.warn("Entrada de datos inválida para getTimestampFromDataPoint:", dataEntry);
                return null;
            }
            const [year, month, day] = dataEntry.fecha.split('-').map(Number);
            let hour = 8, minute = 0; // Mañana (M) por defecto
            if (dataEntry.turno === 'T') { hour = 14; } // Tarde
            else if (dataEntry.turno === 'N') { hour = 20; } // Noche
            
            // Usar Date constructor para hora local. Chart.js adaptadores manejan esto.
            return new Date(year, month - 1, day, hour, minute);
        }
        
        /**
         * Filtra y ordena los datos según el intervalo de tiempo seleccionado.
         */
        function filterAndSortData(data, interval) {
            if (!data || data.length === 0) return [];

            // Asegurar que los datos estén ordenados por fecha y turno
            const sortedData = [...data].sort((a, b) => {
                const tsA = getTimestampFromDataPoint(a);
                const tsB = getTimestampFromDataPoint(b);
                if (!tsA && !tsB) return 0;
                if (!tsA) return 1;
                if (!tsB) return -1;
                return tsA.getTime() - tsB.getTime();
            });

            const lastDataPoint = sortedData[sortedData.length - 1];
            if (!lastDataPoint) return [];
            
            let latestDate = getTimestampFromDataPoint(lastDataPoint);
            if (!latestDate) latestDate = new Date(); // Fallback
            latestDate.setHours(23, 59, 59, 999); // Fin del último día con datos

            let startDate = new Date(latestDate);

            switch (interval) {
                case '24h': // Último día con datos
                    const targetDay = getTimestampFromDataPoint(lastDataPoint);
                    if (!targetDay) return [];
                    startDate.setFullYear(targetDay.getFullYear(), targetDay.getMonth(), targetDay.getDate());
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case '3days':
                    startDate.setDate(latestDate.getDate() - 2);
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case '1week':
                    startDate.setDate(latestDate.getDate() - 6);
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case '2weeks':
                    startDate.setDate(latestDate.getDate() - 13);
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case '1month':
                    startDate.setMonth(latestDate.getMonth() - 1);
                    startDate.setDate(latestDate.getDate() + 1); // Ajustar al día correcto después de restar mes
                    startDate.setHours(0, 0, 0, 0);
                    break;
                default: // Por defecto, último día
                    const defaultTargetDay = getTimestampFromDataPoint(lastDataPoint);
                     if (!defaultTargetDay) return [];
                    startDate.setFullYear(defaultTargetDay.getFullYear(), defaultTargetDay.getMonth(), defaultTargetDay.getDate());
                    startDate.setHours(0, 0, 0, 0);
            }

            return sortedData.filter(d => {
                const timestamp = getTimestampFromDataPoint(d);
                return timestamp && timestamp.getTime() >= startDate.getTime() && timestamp.getTime() <= latestDate.getTime();
            });
        }

        timeIntervalSelector.addEventListener('change', (event) => {
            updateChartView();
        });

        function updateChartView() {
            const selectedInterval = timeIntervalSelector.value;
            currentlyDisplayedData = filterAndSortData(patientData, selectedInterval);
            createChart(currentlyDisplayedData, selectedInterval);
             //renderDataTable(); // Opcional: si la tabla también debe filtrarce. Por ahora la dejamos con todos los datos.
        }
        
        const customAnnotationsPlugin = {
            id: 'customAnnotations',
            afterDatasetsDraw: (chart) => {
                const { ctx, data, chartArea: { top, bottom, left, right }, scales } = chart;
                if (!currentlyDisplayedData || currentlyDisplayedData.length === 0) return;
                
                ctx.save();
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';

                currentlyDisplayedData.forEach((pData, index) => {
                    // Encontrar el índice correspondiente en los datasets del gráfico.
                    // Esto asume que currentlyDisplayedData está en el mismo orden y filtrado que los datos del gráfico.
                    // Y que cada dataset en el gráfico tiene un punto para cada entrada en currentlyDisplayedData.
                    const chartDataIndex = chart.data.datasets[0].data.findIndex(
                        dp => dp && dp.x && getTimestampFromDataPoint(pData) && dp.x.getTime() === getTimestampFromDataPoint(pData).getTime()
                    );

                    if (chartDataIndex === -1) return; // No se encontró el punto en el gráfico

                    const meta = chart.getDatasetMeta(0); // Usar cualquier meta para la posición X
                    if (!meta.data || !meta.data[chartDataIndex]) return;

                    const xPos = meta.data[chartDataIndex].x;
                    
                    // Anotación SatO2
                    if (pData.sato2 !== undefined && pData.sato2 !== null) {
                        ctx.fillStyle = '#1f2937'; 
                        let yAnchor = top + 20; 

                        const tempDatasetIndex = chart.data.datasets.findIndex(ds => ds.label === 'Temperatura');
                        if (tempDatasetIndex !== -1) {
                            const tempMeta = chart.getDatasetMeta(tempDatasetIndex);
                            const tempPoint = tempMeta.data[chartDataIndex];
                            if (tempPoint && tempPoint.active !== false && tempPoint.parsed && tempPoint.parsed.y !== null) {
                                yAnchor = tempPoint.y - 15;
                            } else if (pData.tas) {
                                const bpScale = scales.yBP;
                                if (bpScale) yAnchor = bpScale.getPixelForValue(pData.tas) - 15;
                            }
                        } else if (pData.tas) { // Fallback si no hay dataset de Temp
                             const bpScale = scales.yBP;
                             if (bpScale) yAnchor = bpScale.getPixelForValue(pData.tas) - 15;
                        }


                        if (xPos >= left && xPos <= right && yAnchor > top - 10 && yAnchor < bottom + 10) { 
                            ctx.fillText(String(pData.sato2) + "%", xPos, Math.max(top - 5, Math.min(yAnchor, bottom + 5))); 
                        }
                    }

                    // Anotaciones para valores fuera de escala (Min/Max)
                    ['Temperatura', 'Frec. Cardíaca', 'Frec. Respiratoria'].forEach(label => {
                        const datasetIndex = chart.data.datasets.findIndex(ds => ds.label === label);
                        if (datasetIndex === -1) return;
                        
                        const dataset = chart.data.datasets[datasetIndex];
                        const yScale = scales[dataset.yAxisID];
                        const value = dataset.data[chartDataIndex] ? dataset.data[chartDataIndex].y : null; 

                        if (value === null || value === undefined || !yScale) return;

                        if (value < yScale.min) {
                            ctx.fillStyle = dataset.borderColor || 'black';
                            ctx.fillText(String(value), xPos, bottom + 12);
                        } else if (value > yScale.max) {
                            ctx.fillStyle = dataset.borderColor || 'black';
                            ctx.fillText(String(value), xPos, top - 8);
                        }
                    });
                });
                ctx.restore();
            }
        };


        function createChart(dataToDisplay, interval) {
            if (!dataToDisplay || dataToDisplay.length === 0) {
                console.log("createChart llamado con datos vacíos o nulos.");
                if (vitalSignsChart) vitalSignsChart.destroy();
                // Podrías mostrar un mensaje en el canvas
                const chartContainer = document.getElementById('chartContainer');
                chartContainer.innerHTML = '<canvas id="vitalSignsChart"></canvas><p style="text-align:center; padding: 20px;">No hay datos para mostrar para el período seleccionado.</p>';
                document.getElementById('vitalSignsChart').getContext('2d'); //Re-get context if canvas was replaced
                return;
            } else {
                 const chartContainer = document.getElementById('chartContainer');
                 if (chartContainer.querySelector('p')) { // Remove "no data" message if exists
                    chartContainer.innerHTML = '<canvas id="vitalSignsChart"></canvas>';
                 }
            }
            // console.log("Creando gráfico con datos:", dataToDisplay);

            let timeUnit = 'hour';
            let tooltipFormat = 'dd/MM HH:mm';
            let minRotation = 0;
            let maxRotation = 50;
            let autoSkip = true;

            switch (interval) {
                case '24h': timeUnit = 'hour'; tooltipFormat = 'HH:mm dd/MM'; minRotation = 30; break;
                case '3days': timeUnit = 'day'; tooltipFormat = 'dd/MM/yy'; minRotation = 0; autoSkip = dataToDisplay.length > 20; break;
                case '1week': timeUnit = 'day'; tooltipFormat = 'dd/MM/yy'; autoSkip = dataToDisplay.length > 30; break;
                case '2weeks': timeUnit = 'week'; tooltipFormat = 'Week W, yyyy'; autoSkip = true; break;
                case '1month': timeUnit = 'week'; tooltipFormat = 'Week W, yyyy'; autoSkip = true; break;
            }
            
            const timestamps = dataToDisplay.map(d => getTimestampFromDataPoint(d)).filter(ts => ts !== null);
            let minDate = timestamps.length > 0 ? new Date(Math.min(...timestamps.map(ts => ts.getTime()))) : new Date();
            let maxDate = timestamps.length > 0 ? new Date(Math.max(...timestamps.map(ts => ts.getTime()))) : new Date();

            // Ajustar minDate y maxDate para el intervalo '24h' para cubrir todo el día
            if (interval === '24h' && timestamps.length > 0) {
                minDate.setHours(0,0,0,0);
                maxDate.setHours(23,59,59,999); // Asegura que el maxDate sea el final del último día con datos
            }


            let scalesOptions = {
                x: {
                    type: 'time',
                    time: {
                        unit: timeUnit,
                        tooltipFormat: tooltipFormat,
                        parser: 'iso', // Ya que pasamos objetos Date
                        displayFormats: {
                           hour: 'HH:mm', // Muestra solo hora para 'hour' unit
                           day: 'dd/MM',  // Muestra día/mes para 'day' unit
                           week: 'MMM dd', // Para 'week' unit
                           month: 'MMM yyyy'// Para 'month' unit
                        }
                    },
                    min: minDate.valueOf(), // Usar .valueOf() para pasar el timestamp numérico
                    max: maxDate.valueOf(),
                    grid: { display: true, color: 'rgba(200,200,200,0.2)', borderColor: 'rgba(200,200,200,0.5)', borderDash: [2,3]},
                    ticks: { color: '#555', font: {size: 10}, autoSkip: autoSkip, minRotation: minRotation, maxRotation: maxRotation, source: 'auto'}
                },
                // Las escalas Y se mantienen como las definiste, pero asegúrate que los IDs coincidan
                yTemp: { type: 'linear', position: 'left', display: true, min: parseFloat(document.getElementById('tempMin').value), max: parseFloat(document.getElementById('tempMax').value), title: { display: true, text: 'Temp (°C)', color: 'red', font:{weight:'bold'}}, ticks: { color: 'red', stepSize: 0.5 }, grid: { drawOnChartArea: false }},
                yFC: { type: 'linear', position: 'right', display: true, min: parseFloat(document.getElementById('hrMin').value), max: parseFloat(document.getElementById('hrMax').value), title: { display: true, text: 'FC (lpm)', color: 'blue', font:{weight:'bold'}}, ticks: { color: 'blue', stepSize: 10 }, grid: { drawOnChartArea: false }},
                yFR: { type: 'linear', position: 'right', display: true, min: parseFloat(document.getElementById('rrMin').value), max: parseFloat(document.getElementById('rrMax').value), title: { display: true, text: 'FR (rpm)', color: 'black', font:{weight:'bold'}}, ticks: { color: 'black', stepSize: 5 }, offset: true, grid: { drawOnChartArea: false }},
                yBP: { type: 'linear', position: 'left', display: true, min: parseFloat(document.getElementById('bpMin').value), max: parseFloat(document.getElementById('bpMax').value), title: { display: true, text: 'TA (mmHg)', color: 'green', font:{weight:'bold'}}, ticks: { color: 'green', stepSize: 20 }, grid: { display: true, color: 'rgba(200,200,200,0.3)', borderColor: 'rgba(200,200,200,0.5)'}}
            };

            if (vitalSignsChart) vitalSignsChart.destroy();
            
            const newCtx = document.getElementById('vitalSignsChart').getContext('2d'); // Re-get context in case canvas was replaced

            vitalSignsChart = new Chart(newCtx, {
                // Type 'bar' is overall, lines override this per dataset
                type: 'bar', 
                data: {
                    // Labels no son necesarios para el eje de tiempo cuando se proveen datos {x,y}
                    datasets: [
                        { label: 'Temperatura', data: dataToDisplay.map(d => ({x: getTimestampFromDataPoint(d), y: d.temp === undefined ? null : d.temp})), borderColor: 'red', backgroundColor: 'red', type: 'line', pointStyle: 'circle', radius: 5, hoverRadius: 7, tension: 0.1, yAxisID: 'yTemp', order: 1, spanGaps: true },
                        { label: 'Frec. Cardíaca', data: dataToDisplay.map(d => ({x: getTimestampFromDataPoint(d), y: d.fc === undefined ? null : d.fc})), borderColor: 'blue', backgroundColor: 'blue', type: 'line', pointStyle: 'circle', radius: 5, hoverRadius: 7, tension: 0.1, yAxisID: 'yFC', order: 2, spanGaps: true },
                        { label: 'Frec. Respiratoria', data: dataToDisplay.map(d => ({x: getTimestampFromDataPoint(d), y: d.fr === undefined ? null : d.fr})), borderColor: 'black', backgroundColor: 'black', type: 'line', pointStyle: 'circle', radius: 5, hoverRadius: 7, tension: 0.1, yAxisID: 'yFR', order: 3, spanGaps: true },
                        { label: 'Tensión Arterial', data: dataToDisplay.map(d => ({x: getTimestampFromDataPoint(d), y: (d.tas !== undefined && d.tad !== undefined) ? [d.tad, d.tas] : null })), backgroundColor: 'rgba(46, 204, 113, 0.7)', borderColor: 'green', borderWidth: 1, barPercentage: 0.4, categoryPercentage: 0.5, yAxisID: 'yBP', type: 'bar', order: 0 },
                        { label: 'SatO₂', data: dataToDisplay.map(d => ({ x: getTimestampFromDataPoint(d), y: d.sato2 === undefined ? null : d.sato2 })), hidden: true, yAxisID: 'yTemp' } // No se muestra en leyenda, usado por plugin
                    ]
                },
                options: {
                    responsive: true, 
                    maintainAspectRatio: false, 
                    interaction: { mode: 'index', intersect: false }, 
                    stacked: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { usePointStyle: true, filter: (item) => item.datasetIndex !== 4 }}, // Ocultar SatO2 de la leyenda
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.dataset.label === 'Tensión Arterial' && context.raw && Array.isArray(context.raw.y)) {
                                        label += `${context.raw.y[1]}/${context.raw.y[0]}`; // y es [TAD, TAS]
                                    } else if (context.parsed.y !== null) {
                                        label += context.parsed.y;
                                    }
                                    // Si quieres añadir SatO2 al tooltip general (aunque ya se anota en gráfico):
                                    // const originalDataPoint = currentlyDisplayedData[context.dataIndex];
                                    // if (originalDataPoint && originalDataPoint.sato2 !== undefined && label) {
                                    //    label += ` (SatO₂: ${originalDataPoint.sato2}%)`;
                                    // }
                                    return label;
                                }
                            }
                        },
                        // customAnnotations: {} // El plugin se registra globalmente o al crear el chart
                    },
                    scales: scalesOptions
                },
                plugins: [customAnnotationsPlugin] // Registrar el plugin aquí
            });

            // Para el scroll horizontal: ajustar el ancho del canvas si es necesario
            const chartCanvas = document.getElementById('vitalSignsChart');
            const containerWidth = document.getElementById('chartContainer').offsetWidth;
            // Estimación de ancho necesario. Ajusta el multiplicador (e.g., 50px por punto) según la densidad deseada.
            const desiredCanvasWidth = Math.max(containerWidth, dataToDisplay.length * 60); 
            if (dataToDisplay.length > (containerWidth / 60)) { // Solo si hay muchos puntos
                 chartCanvas.style.width = desiredCanvasWidth + 'px';
            } else {
                chartCanvas.style.width = '100%'; // O el ancho del contenedor
            }
             if (vitalSignsChart) vitalSignsChart.resize(); // Forzar redibujo con nuevo tamaño
        }
        
        applyScaleButton.addEventListener('click', () => updateChartView()); // Actualiza el gráfico con las nuevas escalas

        function renderDataTable() {
            // ... (tu función renderDataTable existente, que usa `patientData` global) ...
            // Esta función no necesita cambios a menos que quieras que la tabla también se filtre.
            // Por ahora, la tabla mostrará todos los datos.
             dataTableBody.innerHTML = '';
            if (!patientData || patientData.length === 0) {
                console.log("renderDataTable: No hay datos para mostrar.");
                return;
            }
            // Ordenar patientData antes de mostrar en la tabla, si no está ya ordenado
            const sortedTableData = [...patientData].sort((a, b) => {
                const tsA = getTimestampFromDataPoint(a);
                const tsB = getTimestampFromDataPoint(b);
                 if (!tsA && !tsB) return 0;
                if (!tsA) return 1; // Mover nulos al final
                if (!tsB) return -1; // Mover nulos al final
                return tsA.getTime() - tsB.getTime();
            });

            sortedTableData.forEach(d => {
                const row = dataTableBody.insertRow();
                let displayDate = '-';
                if (d.fecha) {
                    try {
                        // Para asegurar consistencia, parsear la fecha y luego formatear
                        const dateObj = new Date(d.fecha + 'T00:00:00'); // Asumir que la fecha es local
                        displayDate = dateObj.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });
                    } catch (e) {
                        console.warn("Error al formatear fecha para la tabla:", d.fecha, e);
                    }
                }
                row.insertCell().textContent = displayDate;
                row.insertCell().textContent = d.turno || '-';
                row.insertCell().textContent = d.temp !== undefined && d.temp !== null ? d.temp.toFixed(1) : '-';
                row.insertCell().textContent = (d.tas !== undefined && d.tad !== undefined && d.tas !== null && d.tad !== null) ? `${d.tas}/${d.tad}` : '-';
                row.insertCell().textContent = d.fc !== undefined && d.fc !== null ? d.fc : '-';
                row.insertCell().textContent = d.fr !== undefined && d.fr !== null ? d.fr : '-';
                row.insertCell().textContent = d.sato2 !== undefined && d.sato2 !== null ? d.sato2 : '-';
            });
        }
        
        inputFecha.valueAsDate = new Date(); 

        addDataButton.addEventListener('click', () => {
            // ... (tu lógica existente para añadir datos) ...
            // Al final, después de ordenar patientData:
            // patientData.sort(...); // Ya lo tienes

            updateChartView(); // Actualiza el gráfico
            renderDataTable(); // Actualiza la tabla
        });

        // --- Inicialización al Cargar la Página ---
        setActiveLink(showDashboardLink);
        updateChartView(); // Carga inicial del gráfico con el intervalo por defecto
        renderDataTable(); // Carga inicial de la tabla

    </script>
</body>
</html>
